Problem Statement: Given an integer array arr, find the contiguous subarray (containing at least one number) which
has the largest sum and returns its sum and prints the subarray.

Appr1: Nested Loops
TC-O(N2)
SC-O(1)

Appr2: Kadane's Algorithm
A subarray with a sum less than 0 will always reduce our answer and so this type of subarray cannot be a part of the subarray with maximum sum.
        int max=Integer.MIN_VALUE, sum=0;
        for(int i=0;i<nums.length;i++)
        {
            sum+=nums[i];
            max=Math.max(max, sum);
            if(sum<0)
            {
                sum=0;
            }
        }
        return max;
TC-O(N)
SC-O(1)

Follow-up question:- There might be more than one subarray with the maximum sum. We need to print any of them.
Appr:
Our approach is to store the starting index and the ending index of the subarray. Thus we can easily get the subarray afterward without actually storing the subarray elements.
The subarray always starts at the particular index where the sum variable is equal to 0, and at the ending index, the sum always crosses the previous maximum sum

    public static long maxSubarraySum(int[] arr, int n) {
        long maxi = Long.MIN_VALUE; // maximum sum
        long sum = 0;

        int start = 0;
        int ansStart = -1, ansEnd = -1;
        for (int i = 0; i < n; i++) {

            if (sum == 0) start = i; // starting index

            sum += arr[i];

            if (sum > maxi) {
                maxi = sum;

                ansStart = start;
                ansEnd = i;
            }

            // If sum < 0: discard the sum calculated
            if (sum < 0) {
                sum = 0;
            }
        }

