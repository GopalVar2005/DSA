Given the root of a binary tree, determine if it is a valid binary search tree (BST).

A valid BST is defined as follows:

The left subtree of a node contains only nodes with keys strictly less than the node's key.
The right subtree of a node contains only nodes with keys strictly greater than the node's key.
Both the left and right subtrees must also be binary search trees.

Appr1:niche se(false mila to sidhe upr dete rho) har node ke liye check krte jao shi to true nhi to false

    public boolean isValidBST(TreeNode root) {
        if(root==null)
        {
            return true;
        }
        if(root.left==null && root.right==null)
        {
            return true;
        }
        boolean left = isValidBST(root.left);
        boolean right = isValidBST(root.right);
        if(!left || !right)
        {
            return false;
        }
        long leftVal=Long.MIN_VALUE;
        if(root.left!=null)
        {
            leftVal=max(root.left);
        }
        long rightVal=Long.MAX_VALUE;
        if(root.right!=null)
        {
            rightVal=min(root.right);
        }
        if(leftVal<root.val && root.val<rightVal)
        {
            return true;
        }
        return false;
    }
    public int max(TreeNode root)
    {
        while(root.right!=null)
        {
            root=root.right;
        }
        return root.val;
    }
    public int min(TreeNode root)
    {
        while(root.left!=null)
        {
            root=root.left;
        }
        return root.val;
    }

TC-O(N2) -> min max agr n tk chle
SC-O(N) -> min max for skewed tree

Appr2: better
    class info
    {
        boolean isBst=true;
        Long min=Long.MAX_VALUE;
        Long max=Long.MIN_VALUE;
    }
    public boolean isValidBST(TreeNode root) {
        return find(root).isBst;
    }
    public info find(TreeNode root)
    {
        info self=new info();
        if(root==null)
        {
            return self;
        }
        info left=find(root.left);
        info right=find(root.right);
        self.min=Math.min(left.min, Math.min(right.min, root.val));
        self.max=Math.max(left.max, Math.max(right.max, root.val));
        self.isBst=left.isBst && right.isBst && (left.max<root.val && root.val<right.min);
        return self;
    }
