Problem Statement: Given a Binary Search Tree and a key value return the node in the BST having data equal to ‘key’ otherwise return nullptr.

Appr1: just use Binary Search in form of recursion
    public TreeNode searchBST(TreeNode root, int val) {
        if(root==null)
        {
            return null;
        }
        if(root.val==val)
        {
            return root;
        }
        TreeNode right=null;
        if(root.val<val)
        {
            right=searchBST(root.right, val);
        }
        TreeNode left=null;
        if(root.val>val)
        {
            left=searchBST(root.left, val);
        }
        if(right!=null)
        {
            return right;
        }
        if(left!=null)
        {
            return left;
        }
        return null;
    }

Time Complexity: O(log N) on average, O(N) in worst case.
Space Complexity: O(log N) on average, O(N) in worst case (because of recursion stack).

Appr2: Perform Binary Search with root.right and root.left
        TreeNode temp=root;
        while(temp!=null)
        {
            int num=temp.val;
            if(num==val)
            {
                return temp;
            }
            else if(num<val)
            {
                temp=temp.right;
            }
            else
            {
                temp=temp.left;
            }
        }
        return temp;
    }

Time Complexity: O(log N) average, O(N) worst case.
Space Complexity: O(1).

Bonus code:-
        while(root!=null && root.val!=val)
        {
            root=root.val<val?root.right:root.left;
        }
        return root;
